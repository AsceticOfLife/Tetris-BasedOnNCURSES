# 更新说明

--------

20230922更新：

1.关于方块类中的get方法的**返回值**传递问题：之前是传递一个自定义类型（Point）对象，这样至少会调用一次Point类的复制构造函数，最多可能调用一次复制构造函数和一次赋值运算符（取决于具体的实现）。
因此重新设计考虑传递引用。get方法的目的应该是返回成员数据，这里不允许修改内部成员数据，因此get方法设置为const，并且返回值也设置为const 的引用。

```c++
const Point& GetPos() const { return position; }
```

2.关于方块类中set方法参数类型问题：将**参数中**自定义类型Point 作为const reference类型传递。

3.在方块类中添加默认构造函数：根据effective C++中的规范应该在构造函数中列出所有成员变量，即使调用的是成员变量的默认构造函数。

4.对于各种形状的方块类，添加final声明，表示不允许派生。

5.在具体的方块类中增加一个enum类型常量TypeNum表示方块的状态个数。

6.优化旋转逻辑：点击W键是顺时针旋转方块

7.更新Set方块的位置position的方法：

```c++
// 之前的set方法
void SetPos(const Point &pos) { position = pos; }

// 改方法的缺点是：
// 块的位置信息position是使用get方法从块对象中获得的
// 如果要根据目前块对象的位置更新（比如向左移动），就必须先使用get方法获取位置，再将获取的位置更新（比如x-1）作为参数传递
// 浪费存储空间和降低效率
// 所以增加方法直接可以使块的position左移、右移、下移
// 在Point类中增加如下方法：
// 坐标改动1
void AddX() { x += 1; }
void SubX() { x -= 1; }
void AddY() { y += 1; }
void SubY() { y -= 1; }

// 在Abr_Chunk类中增加如下方法
// 块左移一格
void SetPosLeft() { position.SubX(); }
// 块右移一格
void SetPosRight() { position.AddX(); }
// 块下移一格
void SetPosDown() { position.SubY(); }
```

8.发现Bug：当游戏结束后会直接跳出程序而不会等待用户输入一个字符之后再退出，

9.发现Bug：对于检测碰撞函数check_hit，这个函数首先会相处chunk覆盖的背景版之后再检测是否碰撞，这里的问题是假如这个块在生成时已经覆盖了某些背景板的位置，那么先消除这一操作就会使得覆盖的地方清空。==为什么要先消除再检测：==因为这个函数要检测方块下移、左移或者右移之后是否会碰撞，所以需要判断改变位置之后的块是否发生碰撞，因此需要先消除原来的块覆盖的背景板。==解决方法：==将原地检测和预测下一步检测分成两个函数（还没实现）。

10.修改程序逻辑：现在将方块作为游戏类的一个成员数据（之前是作为成员方法之间传递的一个变量），虽然这个成员数据在运行之间会更换指向动态空间，但是减少了需要在各个成员方法之间作为参数传递的消耗。

11.更新类UML图和函数说明、程序运行逻辑





---------



1.学习了设计模式中的测略模式之后准备修改chunk类的rotate方法，但是发现rotate方法并不是一个可以共享的方法，而是每个不同类型的块专属的方法，于是放弃修改；

2.添加了makefile文件；

3.修改了一些小bug。

# 项目介绍

项目目的：尝试学习开源C++项目，即github上开源的tinytetris项目

项目内容：基于ncursesw库（2023年windows版本，mingw-20230423）完成一个俄罗斯方块游戏

整体设计框架来自于tinytetris项目，但是作者taylorconor虽然写的是c++文件，却只使用了C++四大组成部分中的C部分。因此为了锻炼C++语言中的C和Object-Oriented C++部分的语法掌握和能力，笔者重新设计了这个小游戏，主要是使用Object-Oriented C++部分的知识，以及对于游戏中的逻辑做了部分修改。

## 方块类图

![](images\Abr_Chunk类图.png)

## 游戏类图

![](images\游戏类图.png)

## 程序逻辑

![](images\游戏逻辑.png)

# 依赖库

这个项目需要可视化，因此使用了ncurses库，并且由于过去的ncurses库基本都是linux平台的，所以使用起来不是很方便。

所幸的是在2023年，ncurses发布了windows版本下的库，笔者采用的是mingw编译器版本。

使用上与linux版本几乎没有任何区别。

# 文件夹结构安排

作者将ncurses库均放在项目文件夹下（而非编译器所在目录），一方面是为了保护编译器文件夹的原始状态，另一方面也是提醒笔者这些文件是专用于本项目。这样导致的一个问题是采用g++编译命令会稍微有些复杂。笔者后续会更新makefile或者CMakeLists。

ncursesw：此文件夹下是ncurses库（window版本）的所有头文件。

lib：此文件夹下是库的静态链接。（为什么要有静态链接和动态链接库在md文件中有说明）

Mytetris：此文件夹是程序类实现。

所有的dll文件和config文件：为ncurses动态链接库。

code.cpp：主程序文件

其它就是一些杂项，比如目标文件、md文件等。

# 编译和运行

## 直接运行exe文件

需要在当前目录下运行exe文件，因为动态链接库都在当前文件夹下，并且笔者编译时也是在当前文件夹下编译的。因此在其它文件夹下运行会找不到动态链接库而失败。

## 编译命令

```c++
g++ -c ./Mytetris/chunk.cpp
g++ -c ./Mytetris/mytetris.cpp
g++ code.cpp chunk.o mytetris.o -L ./lib -l ncursesw -o code.exe
```

# 等待更新

1.需要更新makefile文件或者CMakeLists.txt文件使得编译命令更简单。（但是由于库文件的版本限制还是不能跨平台）

2.对于类设计的细化和修改，贯彻面向对象思想。











